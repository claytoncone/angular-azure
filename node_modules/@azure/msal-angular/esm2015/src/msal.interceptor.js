/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import { __decorate } from "tslib";
import { Injectable } from "@angular/core";
import { HttpErrorResponse } from "@angular/common/http";
import { from } from "rxjs";
import { mergeMap, tap } from "rxjs/operators";
import { MsalService } from "./msal.service";
import { BroadcastService } from "./broadcast.service";
import { ServerHashParamKeys } from "msal";
let MsalInterceptor = class MsalInterceptor {
    constructor(auth, broadcastService) {
        this.auth = auth;
        this.broadcastService = broadcastService;
    }
    intercept(req, next) {
        const scopes = this.auth.getScopesForEndpoint(req.url);
        this.auth.getLogger().verbose("Url: " + req.url + " maps to scopes: " + scopes);
        // If there are no scopes set for this request, do nothing.
        if (!scopes) {
            return next.handle(req);
        }
        let token;
        // Acquire a token for this request, and attach as proper auth header.
        return from(this.auth.acquireTokenSilent({ scopes })
            .then((response) => {
            token = response.tokenType === ServerHashParamKeys.ID_TOKEN ? response.idToken.rawIdToken : response.accessToken;
            const authHeader = `Bearer ${token}`;
            return req.clone({
                setHeaders: {
                    Authorization: authHeader,
                }
            });
        }))
            .pipe(mergeMap(nextReq => next.handle(nextReq)), tap(() => { }, err => {
            if (err instanceof HttpErrorResponse && err.status === 401) {
                this.auth.clearCacheForScope(token);
                this.broadcastService.broadcast("msal:notAuthorized", err.message);
            }
        }));
    }
};
MsalInterceptor.ctorParameters = () => [
    { type: MsalService },
    { type: BroadcastService }
];
MsalInterceptor = __decorate([
    Injectable()
], MsalInterceptor);
export { MsalInterceptor };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXNhbC5pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhenVyZS9tc2FsLWFuZ3VsYXIvIiwic291cmNlcyI6WyJzcmMvbXNhbC5pbnRlcmNlcHRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7O0FBRUgsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBS0gsaUJBQWlCLEVBQ3BCLE1BQU0sc0JBQXNCLENBQUM7QUFFOUIsT0FBTyxFQUFjLElBQUksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN4QyxPQUFPLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRS9DLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQWdCLG1CQUFtQixFQUFFLE1BQU0sTUFBTSxDQUFDO0FBR3pELElBQWEsZUFBZSxHQUE1QixNQUFhLGVBQWU7SUFDeEIsWUFBb0IsSUFBaUIsRUFBWSxnQkFBa0M7UUFBL0QsU0FBSSxHQUFKLElBQUksQ0FBYTtRQUFZLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7SUFBRyxDQUFDO0lBRXZGLFNBQVMsQ0FBQyxHQUFxQixFQUFFLElBQWlCO1FBQzlDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZELElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLG1CQUFtQixHQUFHLE1BQU0sQ0FBQyxDQUFDO1FBRWhGLDJEQUEyRDtRQUMzRCxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNCO1FBRUQsSUFBSSxLQUFhLENBQUM7UUFFbEIsc0VBQXNFO1FBQ3RFLE9BQU8sSUFBSSxDQUNQLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQzthQUNuQyxJQUFJLENBQUMsQ0FBQyxRQUFzQixFQUFFLEVBQUU7WUFDN0IsS0FBSyxHQUFHLFFBQVEsQ0FBQyxTQUFTLEtBQUssbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQztZQUNqSCxNQUFNLFVBQVUsR0FBRyxVQUFVLEtBQUssRUFBRSxDQUFDO1lBQ3JDLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQztnQkFDYixVQUFVLEVBQUU7b0JBQ1IsYUFBYSxFQUFFLFVBQVU7aUJBQzVCO2FBQ0osQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDLENBQ1Q7YUFDSSxJQUFJLENBQ0QsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUN6QyxHQUFHLENBQ0MsR0FBRyxFQUFFLEdBQUUsQ0FBQyxFQUNSLEdBQUcsQ0FBQyxFQUFFO1lBQ0YsSUFBSSxHQUFHLFlBQVksaUJBQWlCLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxHQUFHLEVBQUU7Z0JBQ3hELElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3BDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsb0JBQW9CLEVBQUUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQ3RFO1FBQ0wsQ0FBQyxDQUNKLENBQ0osQ0FBQztJQUNWLENBQUM7Q0FDSixDQUFBOztZQXZDNkIsV0FBVztZQUE4QixnQkFBZ0I7O0FBRDFFLGVBQWU7SUFEM0IsVUFBVSxFQUFFO0dBQ0EsZUFBZSxDQXdDM0I7U0F4Q1ksZUFBZSIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBIdHRwUmVxdWVzdCxcclxuICAgIEh0dHBIYW5kbGVyLFxyXG4gICAgSHR0cEV2ZW50LFxyXG4gICAgSHR0cEludGVyY2VwdG9yLFxyXG4gICAgSHR0cEVycm9yUmVzcG9uc2VcclxufSBmcm9tIFwiQGFuZ3VsYXIvY29tbW9uL2h0dHBcIjtcclxuXHJcbmltcG9ydCB7IE9ic2VydmFibGUsIGZyb20gfSBmcm9tIFwicnhqc1wiO1xyXG5pbXBvcnQgeyBtZXJnZU1hcCwgdGFwIH0gZnJvbSBcInJ4anMvb3BlcmF0b3JzXCI7XHJcblxyXG5pbXBvcnQge01zYWxTZXJ2aWNlfSBmcm9tIFwiLi9tc2FsLnNlcnZpY2VcIjtcclxuaW1wb3J0IHsgQnJvYWRjYXN0U2VydmljZSB9IGZyb20gXCIuL2Jyb2FkY2FzdC5zZXJ2aWNlXCI7XHJcbmltcG9ydCB7IEF1dGhSZXNwb25zZSwgU2VydmVySGFzaFBhcmFtS2V5cyB9IGZyb20gXCJtc2FsXCI7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBNc2FsSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhdXRoOiBNc2FsU2VydmljZSAsICBwcml2YXRlIGJyb2FkY2FzdFNlcnZpY2U6IEJyb2FkY2FzdFNlcnZpY2UpIHt9XHJcblxyXG4gICAgaW50ZXJjZXB0KHJlcTogSHR0cFJlcXVlc3Q8YW55PiwgbmV4dDogSHR0cEhhbmRsZXIpOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PiB7XHJcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gdGhpcy5hdXRoLmdldFNjb3Blc0ZvckVuZHBvaW50KHJlcS51cmwpO1xyXG4gICAgICAgIHRoaXMuYXV0aC5nZXRMb2dnZXIoKS52ZXJib3NlKFwiVXJsOiBcIiArIHJlcS51cmwgKyBcIiBtYXBzIHRvIHNjb3BlczogXCIgKyBzY29wZXMpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc2NvcGVzIHNldCBmb3IgdGhpcyByZXF1ZXN0LCBkbyBub3RoaW5nLlxyXG4gICAgICAgIGlmICghc2NvcGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRva2VuOiBzdHJpbmc7XHJcblxyXG4gICAgICAgIC8vIEFjcXVpcmUgYSB0b2tlbiBmb3IgdGhpcyByZXF1ZXN0LCBhbmQgYXR0YWNoIGFzIHByb3BlciBhdXRoIGhlYWRlci5cclxuICAgICAgICByZXR1cm4gZnJvbShcclxuICAgICAgICAgICAgdGhpcy5hdXRoLmFjcXVpcmVUb2tlblNpbGVudCh7IHNjb3BlcyB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlOiBBdXRoUmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHJlc3BvbnNlLnRva2VuVHlwZSA9PT0gU2VydmVySGFzaFBhcmFtS2V5cy5JRF9UT0tFTiA/IHJlc3BvbnNlLmlkVG9rZW4ucmF3SWRUb2tlbiA6IHJlc3BvbnNlLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhIZWFkZXIgPSBgQmVhcmVyICR7dG9rZW59YDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxLmNsb25lKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYXV0aEhlYWRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICApXHJcbiAgICAgICAgICAgIC5waXBlKFxyXG4gICAgICAgICAgICAgICAgbWVyZ2VNYXAobmV4dFJlcSA9PiBuZXh0LmhhbmRsZShuZXh0UmVxKSksXHJcbiAgICAgICAgICAgICAgICB0YXAoXHJcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEh0dHBFcnJvclJlc3BvbnNlICYmIGVyci5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoLmNsZWFyQ2FjaGVGb3JTY29wZSh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdFNlcnZpY2UuYnJvYWRjYXN0KFwibXNhbDpub3RBdXRob3JpemVkXCIsIGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG4iXX0=